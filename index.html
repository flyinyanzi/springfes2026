<!doctype html>
<html lang="zh">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Popups + Long Letter</title>
  <style>
    html, body { height: 100%; }
    body{
      margin:0;
      overflow:hidden;
      background: radial-gradient(1200px 700px at 60% 25%, #2b2f3a, #0d0f14);
      font-family: system-ui, -apple-system, "PingFang SC", "Microsoft YaHei", sans-serif;
      isolation: isolate;
    }

    /* 通用弹窗 */
    .popup{
      position:absolute;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.26);
      box-shadow: 0 18px 40px rgba(0,0,0,.45);
      backdrop-filter: blur(10px);
      user-select:none;
      overflow:hidden;
      transform-origin: 30% 30%;
    }

    .bar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 10px 10px 8px 12px;
      cursor: grab;
      border-bottom: 1px solid rgba(255,255,255,.18);
      background: linear-gradient(to bottom, rgba(255,255,255,.16), rgba(255,255,255,.04));
    }
    .title{
      display:flex;
      align-items:center;
      gap:8px;
      font-size: 12px;
      opacity:.92;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 72%;
      color: rgba(20,20,20,.86);
    }
    .dot{
      width:9px;height:9px;border-radius:50%;
      background: rgba(20,20,20,.28);
      box-shadow: 0 0 0 2px rgba(255,255,255,.30) inset;
      flex: 0 0 auto;
    }
    .close{
      width: 28px;
      height: 28px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,.24);
      background: rgba(255,255,255,.18);
      color: rgba(20,20,20,.75);
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 16px;
      line-height: 1;
    }
    .close:hover{ background: rgba(255,255,255,.30); }

    .content{
      padding: 10px 12px 12px 12px;
      font-size: 14px;
      line-height: 1.6;
      color: rgba(20,20,20,.86);
      user-select:text;
      white-space: pre-wrap;      /* 自动换行 + 支持 \n */
      word-break: break-word;     /* 避免长单词撑爆 */
    }

    /* 短弹窗 */
    .popup.small{ width: 280px; }
    .popup.small .content{ max-height: 120px; overflow:auto; }

    /* 长信窗（大，滚动，不限字数） */
    .popup.letter{
      width: min(720px, calc(100vw - 24px));
      height: min(78vh, 680px);
    }
    .popup.letter .content{
      height: calc(100% - 52px);
      overflow:auto;
      font-size: 15px;
      line-height: 1.75;
      padding: 18px 18px 18px 18px;
    }

    /* 滚动条（可选） */
    .content::-webkit-scrollbar{ width: 10px; }
    .content::-webkit-scrollbar-thumb{
      background: rgba(0,0,0,.12);
      border-radius: 99px;
      border: 2px solid rgba(255,255,255,.55);
    }

    /* 弹出动画 + 轻微抖动 */
    .pop-in{
      animation: popIn .22s ease-out forwards, jitter 1.8s ease-in-out infinite;
      transform: translateY(10px) scale(.98);
      opacity: 0;
    }
    @keyframes popIn{
      to { opacity: 1; transform: translateY(0) scale(1); }
    }
    @keyframes jitter{
      0%,100% { translate: 0 0; }
      50% { translate: 0.6px -0.6px; } /* 很轻的抖动 */
    }

    /* 长信更像漂浮底稿 */
    .floaty{
      animation: popIn .22s ease-out forwards, float 3.2s ease-in-out infinite;
      transform: translateY(10px) scale(.98);
      opacity: 0;
    }
    @keyframes float{
      0%,100% { transform: translateY(0) scale(1); }
      50%     { transform: translateY(-6px) scale(1); }
    }

    .hint{
      position: fixed;
      left: 12px;
      bottom: 12px;
      font-size: 12px;
      opacity: .55;
      color: #fff;
      user-select:none;
    }

    #fx{
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5; /* 平时很低 */
      background: transparent;
    }
    #fx.on-top{
      z-index: 50000; /* 触发时顶上去 */
    }

    body.night-sky{ background: radial-gradient(1100px 700px at 60% 25%, #0b1a3a, #05060d); }

  </style>
</head>
<body>
  <div class="hint">短句：随机顺序且不重复｜长信：最底层｜都可拖拽/关闭</div>
  <canvas id="fx"></canvas>

<script>
  // ========= 编辑贺卡内容：短句 & 长信 =========

  // 柔和色（粉/蓝/绿）
  const pastel = [
    "#ffe0ea", "#ffd9f2", "#ffe9d2", "#fff4cc",
    "#dff7ff", "#d9e8ff", "#e6ddff",
    "#d9ffe9", "#dfffe0", "#e8fff7"
  ];

  // 约 30 条短句（随机顺序，但每条只出现一次）
  const shortMsgs = [
    "希望你每天早上起床都能精神充沛，元气满满迎接新的一天(*´∀`)♪",
    "在冰岛人们相信有精灵的存在，在冰川苔原、溶洞岩石之间，我们总能与自然通灵",
    "希望你每天上下班路上都顺顺利利的",
    "别总熬夜哦",
    "祝愿你天天开心(^○^)",
    "希望你工作顺利(ง•̀ω•́)ง",
    "希望你上班时不会遇到上司的信息轰炸，下班后也能独享悠闲时光",
    "工作忙的时候也要注意休息呀，多多活动手指和颈椎～",
    "祝愿你在咖啡店里遇到的人都亲切和善",
    "希望你每天中午都有好好吃饭",
    "祝愿你能看到更多打动人心的演出，在音乐里治愈自己",
    "祝愿你在大人的世界里依然有一颗纯真的童心",
    "祝愿你在黑暗的魔法世界里能用“呼神护卫”为自己召唤出一头神秘而温暖的牝鹿",
    "祝愿你依然能够在生活的间隙发现那些细微美好的事物",
    "祝愿你每天都能看到蓝天白云以及壮丽的日落",
    "即使工作忙也好好吃饭哦，要注意补充营养呢",
    "祝愿你用最柔软的力量构筑起最坚固的人间",
    "夜里睡觉记得盖好被子哦，别着凉",
    "姨妈期间多喝些温热滋补的东西哦",
    "喝水接力！工作忙的时候也记得多喝水啦",
    "注意天气变化，记得增添衣物，别感冒了",
    "冬天干燥的话记得用护手霜和身体乳哦",
    "他变成了一颗星星，会永远在夜空中闪耀",
    "希望你能去高山大川、隐秘森林、广阔天地……去很多好玩的地方",
    "祝愿你有温柔照亮归途的星光，在疲倦时有喘息安心之所",
    "祝愿你在算法与KPI之外，可以用自己的汗水与泪光创造更多美好奇迹",
    "希望你在自己感兴趣的领域里有美好的体验",
    "祝愿你的2026年如冬日暖阳般温暖、如锦绣繁花般绚烂",
    "祝愿你不用时刻坚强，也可以在长夜与黎明里守住一窗月光",
    "希望你每天下班都能放松，开心度过夜晚的惬意时光"
  ];

  const TRIGGER_TEXT_01 = "他变成了一颗星星，会永远在夜空中闪耀";
  const TRIGGER_TEXT_02 = "祝愿你在黑暗的魔法世界里能用“呼神护卫”为自己召唤出一头神秘而温暖的牝鹿";
  const TRIGGER_TEXT_03 = "祝愿你不用时刻坚强，也可以在长夜与黎明里守住一窗月光";
  const TRIGGER_TEXT_04 = "祝愿你每天都能看到蓝天白云以及壮丽的日落";
  const TRIGGER_TEXT_05 = "祝愿你的2026年如冬日暖阳般温暖、如锦绣繁花般绚烂";
  const TRIGGER_TEXT_06 = "祝愿你在大人的世界里依然有一颗纯真的童心";


  // 最后一封长信（字数不限制）
  const longLetter = `
2025年对我来说是充满迷雾的一年，生活中的、工作中的、关系中的。很多时候都是迷茫的，但又一直坚持信念而不愿随波逐流；去年还对AI抱有疑虑，而今年已在努力用AI平衡生活、加速工作；受困于关系，也在关系中获得宁静与安慰、获得力量。
也渐渐发现，在结果揭晓之前，永远无法知道答案。只能亲自去经历这些或许困难的、狼狈的解决过程，然后在不知不觉中发现答案已逐渐清晰。

所以年末不是结束，而是新的开始。
未来的一切都是未知的，但点亮黑暗的不一定是阳光，也可以是内心的火光。

我感受你的困惑，也祝愿你迈步前行；也许会在岸边逡巡，祝愿你能够被云霞日光与月色抚慰；也许会犹豫不决，也祝愿你勇敢抉择；也许兵荒马乱，也祝愿你汇聚千军万马。

不管我们此刻身在怎样的距离，我都希望你在新的一年能被温柔包围，幸福美满，也能无忧无惧，坚守自己的力量～
新年快乐！

。
`;

  let FIREWORKS_SHOWN = false;

  // ========= 逻辑部分 =========

  const titles = ["温柔提示", "提醒", "消息", "便签", "叮咚"];

  const rand = (min, max) => Math.random() * (max - min) + min;
  const pick = arr => arr[Math.floor(Math.random() * arr.length)];
  const clamp = (n, min, max) => Math.max(min, Math.min(n, max));

  let topZ = 1000;
  let letterShown = false;

  // 洗牌：保证随机顺序且不重复
  function shuffle(arr){
    const a = arr.slice();
    for(let i=a.length-1; i>0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  // 本轮短句队列：每条只用一次
  let shortQueue = shuffle(shortMsgs);
  function nextShort(){
    return shortQueue.length ? shortQueue.shift() : null; // 用完就 null（不再重复）
  }

// ===== FX Canvas 初始化 =====
const FX = (() => {
  const c = document.getElementById("fx");
  const ctx = c.getContext("2d");
  let w = 0, h = 0, dpr = 1;

  function resize(){
    dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    w = c.width = Math.floor(window.innerWidth * dpr);
    h = c.height = Math.floor(window.innerHeight * dpr);
    c.style.width = window.innerWidth + "px";
    c.style.height = window.innerHeight + "px";
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr, dpr);
  }
  window.addEventListener("resize", resize);
  resize();

  function clear(){
    ctx.clearRect(0,0,window.innerWidth,window.innerHeight);
  }

  return { c, ctx, clear };
})();

let EFFECT_LOCK = false; // 防止同时触发多个

// ===== Effect 01：夜空 + 流星 =====
function triggerEffect_01(){
  if(EFFECT_LOCK) return;
  EFFECT_LOCK = true;
  FX.c.classList.add("on-top");

  document.body.classList.add("night-sky");

  const ctx = FX.ctx;
  const W = window.innerWidth, H = window.innerHeight;

  const stars = Array.from({length: Math.floor((W*H)/12000)}, () => ({
    x: Math.random()*W,
    y: Math.random()*H,
    r: Math.random()*1.2 + 0.2,
    a: Math.random()*0.7 + 0.1
  }));

  const start = performance.now();
  const dur = 2400;

  // 暗场：先压暗，再释放
  const darkIn = 500;     // 0.5s 暗下来
  const darkHold = 1500;   // 暗场维持
  const darkOut = 700;    // 0.7s 恢复
  const darkTotal = darkIn + darkHold + darkOut;

  const sx = -300;
  const sy = window.innerHeight + 240;
  const ex = window.innerWidth + 420;
  const ey = -260;

  const vx = ex - sx;
  const vy = ey - sy;
  const theta = Math.atan2(vy, vx);

  function easeOutCubic(t){ return 1 - Math.pow(1-t, 3); }

  function frame(t){
    const p = Math.min(1, (t - start) / dur);
    FX.clear();

    // ===== 先整体变暗（每帧都画，才不会被 FX.clear 清掉）=====
    const e = Math.min(1, (t - start) / darkTotal);
    let darkA;
    if((t-start) < darkIn){
      darkA = easeOutCubic((t-start)/darkIn);
    }else if((t-start) < darkIn + darkHold){
      darkA = 1;
    }else{
      darkA = 1 - easeOutCubic(((t-start) - darkIn - darkHold)/darkOut);
    }
    darkA = Math.max(0, Math.min(1, darkA));

    // 暗幕
    ctx.globalAlpha = 0.55 * darkA; // ← 数值越高越暗
    ctx.fillStyle = "rgba(0,0,0,1)";
    ctx.fillRect(0,0,W,H);
    ctx.globalAlpha = 1;

    // 蓝雾（暗场里更明显）
    ctx.globalAlpha = 0.35 * darkA;
    const mist = ctx.createRadialGradient(W*0.55, H*0.6, 40, W*0.55, H*0.6, Math.max(W,H));
    mist.addColorStop(0, "rgba(120,190,255,0.20)");
    mist.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = mist;
    ctx.fillRect(0,0,W,H);
    ctx.globalAlpha = 1;

    // ===== stars（暗场里更显眼）=====
    for(const s of stars){
      ctx.globalAlpha = s.a * (0.55 + 0.45*darkA);
      ctx.fillStyle = "#fff";
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // ===== 豪华流星效果 start =====
    const x = sx + vx * p;
    const y = sy + vy * p;

    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(theta);

    const tailLen = Math.max(window.innerWidth, window.innerHeight) * 0.95;
    const headGlow = 110;

    let g = ctx.createLinearGradient(-tailLen, 0, 0, 0);
    g.addColorStop(0.00, "rgba(255,255,255,0)");
    g.addColorStop(0.35, "rgba(120,190,255,0.18)");
    g.addColorStop(0.70, "rgba(255,255,255,0.95)");
    g.addColorStop(1.00, "rgba(255,255,255,0)");

    ctx.strokeStyle = g;
    ctx.lineWidth = 4.8;
    ctx.shadowColor = "rgba(200,230,255,0.95)";
    ctx.shadowBlur = 30;

    ctx.beginPath();
    ctx.moveTo(-tailLen, 0);
    ctx.lineTo(0, 0);
    ctx.stroke();

    g = ctx.createLinearGradient(-tailLen, 0, 0, 0);
    g.addColorStop(0.00, "rgba(255,255,255,0)");
    g.addColorStop(0.55, "rgba(160,220,255,0.10)");
    g.addColorStop(0.90, "rgba(160,220,255,0.35)");
    g.addColorStop(1.00, "rgba(255,255,255,0)");

    ctx.shadowBlur = 0;
    ctx.strokeStyle = g;
    ctx.lineWidth = 14;
    ctx.beginPath();
    ctx.moveTo(-tailLen * 0.9, 0);
    ctx.lineTo(0, 0);
    ctx.stroke();

    ctx.fillStyle = "rgba(255,255,255,0.98)";
    ctx.beginPath();
    ctx.arc(0, 0, 4.5, 0, Math.PI * 2);
    ctx.fill();

    const halo = ctx.createRadialGradient(0, 0, 0, 0, 0, headGlow);
    halo.addColorStop(0, "rgba(200,235,255,0.62)");
    halo.addColorStop(1, "rgba(200,235,255,0)");
    ctx.fillStyle = halo;
    ctx.beginPath();
    ctx.arc(0, 0, headGlow, 0, Math.PI * 2);
    ctx.fill();

    const sparks = 18;
    for(let i=0;i<sparks;i++){
      const back = Math.random() * 220 + 20;
      const spread = (Math.random() - 0.5) * 26;
      const r = Math.random()*1.8 + 0.6;
      ctx.globalAlpha = 0.55 * (1 - p) * (Math.random()*0.7+0.3);
      ctx.fillStyle = "rgba(220,250,255,1)";
      ctx.beginPath();
      ctx.arc(-back, spread, r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    ctx.restore();
    // ===== 豪华流星效果 end =====

    if(p < 1){
      requestAnimationFrame(frame);
    }else{
      setTimeout(() => {
        FX.clear();
        FX.c.classList.remove("on-top");
        EFFECT_LOCK = false;
      }, 220);
    }
  }

  requestAnimationFrame(frame);
}

// ===== Effect 02：呼神护卫（雌鹿轮廓 + 粒子汇聚 + 发光）=====
function triggerEffect_02(){
  FX.c.classList.add("on-top");
  if(EFFECT_LOCK) return;
  EFFECT_LOCK = true;

  // 背景变蓝
  document.body.style.background =
  "radial-gradient(1200px 700px at 60% 30%, #1a2e5a, #06070f)";

  const ctx = FX.ctx;
  const W = window.innerWidth, H = window.innerHeight;

  const start = performance.now();
  const durSummon = 1800;  // 汇聚阶段
  const durHold   = 2400;  // 鹿显现与呼吸
  const total     = durSummon + durHold;

  // 粒子：从四周漂向中心偏右的位置（像咒语光芒聚集）
  const target = { x: W*0.55, y: H*0.60 };
  const particles = Array.from({length: 520}, () => {
    const edge = Math.floor(Math.random()*4);
    let x,y;
    if(edge===0){ x=Math.random()*W; y=-30; }
    if(edge===1){ x=W+30; y=Math.random()*H; }
    if(edge===2){ x=Math.random()*W; y=H+30; }
    if(edge===3){ x=-30; y=Math.random()*H; }
    return {
      x, y,
      vx: 0, vy: 0,
      r: Math.random()*1.6 + 0.4,
      a: Math.random()*0.65 + 0.15
    };
  });

  // ===== “银蓝色光之牝鹿”建模 start =====
  function drawDoeOutline(x, y, s, glow, breathe){
    const t = performance.now();
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(s, s);

    // 轻微“呼吸”缩放
    const b = breathe ? (1 + 0.015*Math.sin(t/240)) : 1;
    ctx.scale(b, b);

    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    // ===== 轮廓路径（更像鹿：头、颈、背线、胸腹、腿）=====
    function pathDoe(){
      ctx.beginPath();

      // 背线 + 臀部
      ctx.moveTo(-170, 20);
      ctx.quadraticCurveTo(-120, -10, -70, -12);
      ctx.quadraticCurveTo(-10, -18,  55, -20);
      ctx.quadraticCurveTo(110, -18, 150,  10);

      // 胸腹线
      ctx.quadraticCurveTo(175,  35, 160,  70);
      ctx.quadraticCurveTo(145, 110, 120, 125);
      ctx.quadraticCurveTo( 90, 145,  50, 140);
      ctx.quadraticCurveTo(  0, 133, -60, 120);
      ctx.quadraticCurveTo(-115, 108, -150,  80);
      ctx.quadraticCurveTo(-175,  60, -170,  20);

      // 颈与头（右侧朝前）
      ctx.moveTo(135, 10);
      ctx.quadraticCurveTo(160, -40, 125, -95);
      ctx.quadraticCurveTo(105, -125,  70, -140);
      ctx.quadraticCurveTo( 35, -155,  10, -140);
      ctx.quadraticCurveTo( 25, -125,  45, -120);
      ctx.quadraticCurveTo( 78, -112,  98, -95);
      ctx.quadraticCurveTo(125, -70, 120, -35);
      ctx.quadraticCurveTo(118,  -5, 135,  10);

      // 耳朵（两只）
      ctx.moveTo(72, -140);
      ctx.quadraticCurveTo(78, -172, 98, -186);
      ctx.moveTo(52, -138);
      ctx.quadraticCurveTo(56, -168, 72, -178);

      // 前腿（两条错位）
      ctx.moveTo(125, 125);
      ctx.quadraticCurveTo(130, 160, 120, 190);
      ctx.quadraticCurveTo(112, 210,  98, 214);

      ctx.moveTo(105, 128);
      ctx.quadraticCurveTo(108, 162, 100, 188);
      ctx.quadraticCurveTo( 92, 212,  78, 214);

      // 后腿（两条错位）
      ctx.moveTo(-60, 120);
      ctx.quadraticCurveTo(-70, 160, -62, 192);
      ctx.quadraticCurveTo(-55, 212, -40, 214);

      ctx.moveTo(-88, 112);
      ctx.quadraticCurveTo(-98, 150, -92, 182);
      ctx.quadraticCurveTo(-86, 210, -70, 214);
    }

    // ===== 外辉（粗描边）=====
    ctx.save();
    ctx.globalAlpha = 0.95 * glow;
    ctx.shadowColor = "rgba(170,230,255,0.95)";
    ctx.shadowBlur  = 42;
    ctx.strokeStyle = "rgba(190,240,255,0.35)";
    ctx.lineWidth   = 22;
    pathDoe();
    ctx.stroke();
    ctx.restore();

    // ===== 内亮线（细描边）=====
    ctx.save();
    ctx.globalAlpha = 0.95 * glow;
    ctx.shadowBlur = 0;
    ctx.strokeStyle = "rgba(235,255,255,0.95)";
    ctx.lineWidth   = 2.4;
    pathDoe();
    ctx.stroke();
    ctx.restore();

    // ===== “能量雾丝带”（让它更像你图里的光雾）=====
    ctx.save();
    ctx.globalAlpha = 0.22 * glow;
    for(let i=0;i<36;i++){
      const px = -120 + Math.random()*320;
      const py = -120 + Math.random()*360;
      const r  = 18 + Math.random()*48;
      const a  = 0.10 + Math.random()*0.18;

      const rg = ctx.createRadialGradient(px, py, 0, px, py, r);
      rg.addColorStop(0, `rgba(190,240,255,${a})`);
      rg.addColorStop(1, "rgba(190,240,255,0)");
      ctx.fillStyle = rg;
      ctx.beginPath();
      ctx.arc(px, py, r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();

    // 胸口“脉冲光”（呼吸点）
    if(breathe){
      const pulse = 0.5 + 0.5*Math.sin(t/220);
      const rg = ctx.createRadialGradient(120, 35, 0, 120, 35, 85);
      rg.addColorStop(0, `rgba(220,255,255,${0.25 + 0.25*pulse})`);
      rg.addColorStop(1, "rgba(220,255,255,0)");
      ctx.fillStyle = rg;
      ctx.beginPath();
      ctx.arc(120, 35, 85, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.restore();
  }
  // ===== “银蓝色光之牝鹿”建模 end =====

  function frame(t){
    const elapsed = t - start;
    FX.clear();

    // 背景轻暗 + 银蓝雾
    ctx.globalAlpha = 0.55;
    const bg = ctx.createRadialGradient(W*0.6, H*0.55, 40, W*0.6, H*0.55, Math.max(W,H));
    bg.addColorStop(0, "rgba(120,190,255,0.18)");
    bg.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = bg;
    ctx.fillRect(0,0,W,H);
    ctx.globalAlpha = 1;

    // 阶段 1：粒子汇聚
    const p1 = Math.min(1, elapsed / durSummon);
    const ease = (x)=>1-Math.pow(1-x,3);

    for(const pt of particles){
      const ex = ease(p1);
      // 朝目标靠拢 + 一点旋绕
      const dx = target.x - pt.x;
      const dy = target.y - pt.y;
      pt.x += dx * (0.012 + 0.018*ex);
      pt.y += dy * (0.012 + 0.018*ex);

      // 旋绕
      const swirl = 0.006 + 0.012*ex;
      const ox = -dy * swirl;
      const oy =  dx * swirl;
      pt.x += ox;
      pt.y += oy;

      ctx.globalAlpha = pt.a * (0.25 + 0.85*ex);
      ctx.fillStyle = "rgba(220,250,255,1)";
      ctx.beginPath();
      ctx.arc(pt.x, pt.y, pt.r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // 阶段 2：雌鹿显现 + 轻微游动
    if(elapsed > durSummon){
      const p2 = Math.min(1, (elapsed - durSummon) / durHold);
      const glow = 0.2 + 0.8 * ease(p2);

      const breath = Math.sin((elapsed - durSummon) / 280) * 0.5 + 0.5; // 0~1
      const bob = (Math.sin((elapsed - durSummon)/900) * 10);          // 轻微上下

      const x = target.x;
      const y = target.y + bob;
      const scale = 1.05 + 0.03*breath;

      drawDoeOutline(x, y, 1.00, glow, true);

      // 一点“魔法爆闪”
      ctx.globalAlpha = 0.18 * glow * (1-p2);
      ctx.fillStyle = "rgba(230,255,255,1)";
      ctx.beginPath();
      ctx.arc(x, y, 140, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    if(elapsed < total){
      requestAnimationFrame(frame);
    }else{
      // 慢慢清掉
      const endStart = performance.now();
      const fadeDur = 600;
      (function fade(tt){
        const pp = Math.min(1, (tt - endStart)/fadeDur);
        ctx.globalAlpha = 1 - pp;
        // 轻轻再画一帧雾（减少突兀）
        ctx.fillStyle = "rgba(0,0,0,0.06)";
        ctx.fillRect(0,0,W,H);
        ctx.globalAlpha = 1;
        if(pp < 1) requestAnimationFrame(fade);
        else { FX.clear(); FX.c.classList.remove("on-top"); EFFECT_LOCK = false; }
      })(endStart);
    }
  }

  requestAnimationFrame(frame);
}

// ===== Effect 03：窗前月光照亮屏幕 =====
function triggerEffect_03(){
  if(EFFECT_LOCK) return;
  EFFECT_LOCK = true;

  // 触发时置顶
  FX.c.classList.add("on-top");

  const ctx = FX.ctx;
  const W = window.innerWidth, H = window.innerHeight;

  const start = performance.now();
  const durIn  = 1200;   // 亮起
  const durHold = 1700;  // 停留
  const durOut = 900;    // 淡出
  const total = durIn + durHold + durOut;

  // 月亮位置：右上角
  const moon = { x: W*0.84, y: H*0.18, r: Math.min(W,H)*0.085 };

  // 画弯月：用“两个圆相减”的方式
  function drawCrescent(x, y, r, phase){
    ctx.save();

    // phase: 0~1，越大越细
    const offset = r * (0.55 + 0.35*phase);

    // === 1) 用 evenodd 裁出“月牙形状” ===
    ctx.beginPath();
    // 外圆
    ctx.arc(x, y, r, 0, Math.PI*2, false);
    // 内圆（反向）
    ctx.arc(x + offset, y - r*0.08, r*0.98, 0, Math.PI*2, true);
    // 关键：evenodd = 外圆 - 内圆
    ctx.clip("evenodd");

    // === 2) 在月牙区域内画月光 ===
    ctx.globalCompositeOperation = "lighter";
    ctx.globalAlpha = 0.9;

    const glowR = r * 2.4;
    const rg = ctx.createRadialGradient(
      x, y, r*0.2,
      x, y, glowR
    );
    rg.addColorStop(0, "rgba(230,255,255,0.55)");
    rg.addColorStop(0.6, "rgba(180,230,255,0.18)");
    rg.addColorStop(1, "rgba(180,230,255,0)");
    ctx.fillStyle = rg;

    ctx.beginPath();
    ctx.arc(x, y, glowR, 0, Math.PI*2);
    ctx.fill();

    // === 3) 月面实体（仍然被 clip 限制为月牙） ===
    ctx.globalCompositeOperation = "source-over";
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = "rgba(245,255,255,0.95)";
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
    ctx.globalCompositeOperation = "source-over";
  }

  function easeOutCubic(t){ return 1 - Math.pow(1-t, 3); }
  function easeInOut(t){
    return t<0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2;
  }

  function frame(t){
    const elapsed = t - start;
    const p = Math.min(1, elapsed / total);

    FX.clear();

    // ===== 整体压暗 =====
    let darkAlpha;
    if(elapsed < durIn){
      darkAlpha = easeOutCubic(elapsed / durIn);
    }else if(elapsed < durIn + durHold){
      darkAlpha = 1;
    }else{
      darkAlpha = 1 - easeOutCubic((elapsed - durIn - durHold) / durOut);
    }

    // 暗色覆盖层
    ctx.globalAlpha = 0.45 * darkAlpha;   // ← 数值可调（0.35~0.55）
    ctx.fillStyle = "rgba(0,0,0,1)";
    ctx.fillRect(0, 0, W, H);
    ctx.globalAlpha = 1;

    // ===== 背景“月光点亮”：一个从右上角扩散的蓝白光晕 + 整体提亮 =====
    let a;
    if(elapsed < durIn){
      a = easeOutCubic(elapsed/durIn);
    }else if(elapsed < durIn + durHold){
      a = 1;
    }else{
      a = 1 - easeOutCubic((elapsed - durIn - durHold)/durOut);
    }

    // 1) 整体轻微提亮（像月光照亮空气）
    ctx.globalAlpha = 0.18 * a;
    ctx.fillStyle = "rgba(255,255,255,1)";
    ctx.fillRect(0,0,W,H);

    // 2) 右上角月光光束（主光晕）
    ctx.globalAlpha = 1.05 * a;
    const beamR = Math.max(W,H) * 0.95;
    const beam = ctx.createRadialGradient(moon.x, moon.y, 20, moon.x, moon.y, beamR);
    beam.addColorStop(0, "rgba(210,245,255,0.35)");
    beam.addColorStop(0.25, "rgba(160,220,255,0.18)");
    beam.addColorStop(0.65, "rgba(120,180,255,0.08)");
    beam.addColorStop(1, "rgba(120,180,255,0)");
    ctx.fillStyle = beam;
    ctx.fillRect(0,0,W,H);

    // 3) 很淡的“光束方向感”（斜向下）
    ctx.globalAlpha = 0.16 * a;
    ctx.save();
    ctx.translate(moon.x, moon.y);
    ctx.rotate(22 * Math.PI/180);
    const grad = ctx.createLinearGradient(0, 0, 0, H*1.3);
    grad.addColorStop(0, "rgba(220,250,255,0.35)");
    grad.addColorStop(0.5, "rgba(220,250,255,0.12)");
    grad.addColorStop(1, "rgba(220,250,255,0)");
    ctx.fillStyle = grad;
    ctx.fillRect(-W*0.25, 0, W*0.6, H*1.25);
    ctx.restore();

    // 4) 弯月本体（phase 越大越细）
    const phase = 0.65; // 你想更细：0.8；更胖：0.45
    drawCrescent(moon.x, moon.y, moon.r, phase);

    // 5) 轻微星点（可选）
    ctx.globalAlpha = 0.28 * a;
    for(let i=0;i<120;i++){
      const x = Math.random()*W;
      const y = Math.random()*H*0.6;
      const r = Math.random()*1.2 + 0.2;
      ctx.fillStyle = "rgba(255,255,255,1)";
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    if(elapsed < total){
      requestAnimationFrame(frame);
    }else{
      FX.clear();
      FX.c.classList.remove("on-top");
      EFFECT_LOCK = false;
    }
  }

  requestAnimationFrame(frame);
}

// ===== Effect 04：画面被染晚霞日落 =====
function triggerEffect_04(){
  if(EFFECT_LOCK) return;
  EFFECT_LOCK = true;

  FX.c.classList.add("on-top");

  const ctx = FX.ctx;
  const W = window.innerWidth, H = window.innerHeight;

  const start = performance.now();
  const durIn = 1200;    // 晚霞铺开 + 太阳出现
  const durHold = 1200;  // 停留
  const durOut = 900;    // 淡出
  const total = durIn + durHold + durOut;

  function easeOutCubic(t){ return 1 - Math.pow(1-t, 3); }
  function easeInOut(t){
    return t<0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2;
  }

  // 太阳位置（从中间偏上，缓慢落到地平线附近）
  const sunX = W * 0.5;
  const horizonY = H * 0.62;         // 地平线
  const sunR = Math.min(W, H) * 0.09;

  function frame(now){
    const elapsed = now - start;

    // 进/停/出 的整体透明度 a
    let a;
    if(elapsed < durIn) a = easeOutCubic(elapsed/durIn);
    else if(elapsed < durIn + durHold) a = 1;
    else a = 1 - easeOutCubic((elapsed - durIn - durHold)/durOut);
    a = Math.max(0, Math.min(1, a));

    FX.clear();

    // ===== 1) 满屏晚霞染色（橘/粉/紫渐变）=====
    // 用一个从上到下的渐变，再叠一点中心光晕
    ctx.globalAlpha = 0.92 * a;
    const sky = ctx.createLinearGradient(0, 0, 0, H);
    sky.addColorStop(0.00, "rgba(255,165,90,0.85)");  // 橘
    sky.addColorStop(0.35, "rgba(255,120,120,0.55)"); // 粉橘
    sky.addColorStop(0.70, "rgba(255,90,140,0.28)");  // 玫红
    sky.addColorStop(1.00, "rgba(120,80,160,0.18)");  // 紫暮
    ctx.fillStyle = sky;
    ctx.fillRect(0,0,W,H);

    // 中心“霞光爆开”
    ctx.globalAlpha = 0.65 * a;
    const bloom = ctx.createRadialGradient(W*0.5, H*0.42, 10, W*0.5, H*0.42, Math.max(W,H)*0.75);
    bloom.addColorStop(0, "rgba(255,220,160,0.55)");
    bloom.addColorStop(0.35, "rgba(255,170,120,0.25)");
    bloom.addColorStop(1, "rgba(255,170,120,0)");
    ctx.fillStyle = bloom;
    ctx.fillRect(0,0,W,H);

    // ===== 2) 地平线（薄雾）=====
    ctx.globalAlpha = 0.55 * a;
    const haze = ctx.createLinearGradient(0, horizonY-120, 0, horizonY+120);
    haze.addColorStop(0, "rgba(255,230,190,0)");
    haze.addColorStop(0.5, "rgba(255,230,190,0.22)");
    haze.addColorStop(1, "rgba(255,230,190,0)");
    ctx.fillStyle = haze;
    ctx.fillRect(0, horizonY-120, W, 240);

    // ===== 3) 太阳下沉（关键）=====
    // sunY：从稍高处缓慢落到 horizonY
    const fallP = easeInOut(Math.min(1, elapsed/(durIn+durHold))); // 下沉进度（进+停）
    const sunYStart = H*0.46;
    const sunY = sunYStart + (horizonY - sunYStart) * fallP;

    // 太阳本体（柔边缘）
    ctx.globalAlpha = 0.95 * a;
    const sunGrad = ctx.createRadialGradient(sunX, sunY, sunR*0.2, sunX, sunY, sunR*1.6);
    sunGrad.addColorStop(0, "rgba(255,255,245,0.98)");
    sunGrad.addColorStop(0.35, "rgba(255,235,170,0.85)");
    sunGrad.addColorStop(1, "rgba(255,200,120,0)");
    ctx.fillStyle = sunGrad;
    ctx.beginPath();
    ctx.arc(sunX, sunY, sunR*1.6, 0, Math.PI*2);
    ctx.fill();

    // 太阳核心
    ctx.globalAlpha = 0.92 * a;
    ctx.fillStyle = "rgba(255,245,220,0.9)";
    ctx.beginPath();
    ctx.arc(sunX, sunY, sunR, 0, Math.PI*2);
    ctx.fill();

    // ===== 4) “日落切线”遮罩：让太阳像沉到地平线里 =====
    // 用 destination-out 在地平线下掏掉太阳下半部分（随着 fallP 增加掏得更多）
    ctx.save();
    ctx.globalCompositeOperation = "destination-out";
    ctx.globalAlpha = 1;
    const cutY = horizonY - (1 - fallP) * (sunR*0.65); // 初期切得少，后期切得多
    ctx.fillStyle = "rgba(0,0,0,1)";
    ctx.fillRect(0, cutY, W, H - cutY);
    ctx.restore();

    // ===== 5) 水平光带（很“日落”）=====
    ctx.globalAlpha = 0.35 * a;
    const band = ctx.createLinearGradient(0, horizonY-8, 0, horizonY+8);
    band.addColorStop(0, "rgba(255,255,255,0)");
    band.addColorStop(0.5, "rgba(255,240,210,0.55)");
    band.addColorStop(1, "rgba(255,255,255,0)");
    ctx.fillStyle = band;
    ctx.fillRect(0, horizonY-16, W, 32);

    // ===== 5.5) 海面反光（金色竖条 + 轻微波纹抖动）=====
    ctx.save();
    ctx.globalAlpha = 0.55 * a;

    // 反光宽度随时间轻微抖动（像水面）
    const shimmer = 0.5 + 0.5*Math.sin(now/120);
    const colW = W * (0.08 + 0.03*shimmer);  // 反光柱宽度
    const colH = H * 0.36;                  // 反光柱高度（从地平线往下）

    // 竖向渐变：上亮下淡
    const col = ctx.createLinearGradient(0, horizonY, 0, horizonY + colH);
    col.addColorStop(0.00, "rgba(255,240,200,0.65)");
    col.addColorStop(0.20, "rgba(255,210,140,0.38)");
    col.addColorStop(0.55, "rgba(255,170,110,0.18)");
    col.addColorStop(1.00, "rgba(255,170,110,0)");

    ctx.fillStyle = col;

    // 用多条窄矩形叠出“抖动的水纹”
    const stripes = 22;
    for(let i=0;i<stripes;i++){
      const k = i/(stripes-1);                 // 0~1
      const y = horizonY + k*colH;
      const wave = Math.sin(now/90 + k*8) * (2 + 6*(1-k)); // 上方更稳，下方更抖
      const w = colW * (1 - 0.6*k) + Math.sin(now/140 + k*5)*6;
      const x = sunX - w/2 + wave;

      // 每条的高度越往下越薄
      const hh = 3 + (1-k)*5;
      ctx.globalAlpha = (0.42 * a) * (1-k) * (0.6 + 0.4*Math.random());
      ctx.fillRect(x, y, w, hh);
    }
    ctx.restore();
    ctx.globalAlpha = 1;

    // ===== 6) 少量颗粒（让晚霞更有质感）=====
    ctx.globalAlpha = 0.10 * a;
    for(let i=0;i<140;i++){
      const x = Math.random()*W;
      const y = Math.random()*H;
      const r = Math.random()*1.4 + 0.2;
      ctx.fillStyle = "rgba(255,255,255,1)";
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    if(elapsed < total){
      requestAnimationFrame(frame);
    }else{
      FX.clear();
      FX.c.classList.remove("on-top");
      EFFECT_LOCK = false;
    }
  }

  requestAnimationFrame(frame);
}

// ===== Effect 05：满屏花海盛放 =====
function triggerEffect_05(){
  if(EFFECT_LOCK) return;
  EFFECT_LOCK = true;
  FX.c.classList.add("on-top");

  const ctx = FX.ctx;
  const W = window.innerWidth, H = window.innerHeight;

  const start = performance.now();
  const durIn = 1100;    // 爆开
  const durHold = 1700;  // 盛开停留
  const durOut = 900;    // 淡出
  const total = durIn + durHold + durOut;

  const bg = [
    "#ff2d55", "#ff3b30", "#ff9500", "#ffd60a",
    "#34c759", "#00c7be", "#0a84ff", "#5e5ce6",
    "#bf5af2", "#ff375f"
  ];

  const petalPal = [
    "#ff2d55", "#ff375f", "#ff453a", "#ff9f0a",
    "#ffd60a", "#30d158", "#64d2ff", "#0a84ff",
    "#5e5ce6", "#bf5af2", "#ff7eb6", "#ffb86c"
  ];

  const rand = (a,b)=>Math.random()*(b-a)+a;
  const pick = arr => arr[(Math.random()*arr.length)|0];
  const easeOutCubic = t => 1 - Math.pow(1-t,3);

  // 花朵对象
  const flowers = [];
  const count = Math.min(220, Math.floor((W*H)/2200)); // 屏幕越大越多
  for(let i=0;i<count;i++){
    flowers.push({
      x: rand(-60, W+60),
      y: rand(-60, H+60),
      s: rand(0.55, 1.35),
      rot: rand(0, Math.PI*2),
      vr: rand(-0.012, 0.012),
      vy: rand(-0.10, 0.18),
      vx: rand(-0.12, 0.12),
      kind: (Math.random()*6)|0,  // 0~5 六种花型
      c1: pick(petalPal),
      c2: pick(petalPal),
      core: pick(["#fff5c2","#fff","#ffe066","#ffd1dc","#e9ff70","#b8ffea"]),
      pop: rand(0.6, 1.6),        // “开花”速度差
      a: rand(0.70, 0.98),
    });
  }

  // 花粉亮点
  const pollen = Array.from({length: 240}, () => ({
    x: rand(0,W),
    y: rand(0,H),
    r: rand(0.6, 1.6),
    a: rand(0.06, 0.18),
    vy: rand(-0.20, -0.06),
    vx: rand(-0.10, 0.10),
  }));

  // ===== 画花：六种简易但“像花”的形状 =====
  function drawFlower(f, open){
    ctx.save();
    ctx.translate(f.x, f.y);
    ctx.rotate(f.rot);

    const S = 22 * f.s * open; // open: 0~1
    const petals = [6, 7, 8, 10, 12][(f.kind%5)];
    const petR = S * rand(0.85, 1.05);

    // 外发光（更鲜艳）
    ctx.globalAlpha = f.a * 0.9;
    ctx.shadowColor = f.c1;
    ctx.shadowBlur = 18;

    // 花瓣渐变
    const g = ctx.createRadialGradient(0,0,2,0,0,petR*1.2);
    g.addColorStop(0, f.c2);
    g.addColorStop(1, f.c1);
    ctx.fillStyle = g;

    // 不同花型：用不同的花瓣参数组合
    for(let i=0;i<petals;i++){
      ctx.save();
      ctx.rotate((Math.PI*2/petals)*i);

      ctx.beginPath();
      if(f.kind===0){
        // 圆润花瓣
        ctx.ellipse(petR*0.55, 0, petR*0.55, petR*0.28, 0, 0, Math.PI*2);
      }else if(f.kind===1){
        // 尖瓣（像百合/郁金香的抽象）
        ctx.moveTo(0,0);
        ctx.quadraticCurveTo(petR*0.75, -petR*0.25, petR*1.05, 0);
        ctx.quadraticCurveTo(petR*0.75,  petR*0.25, 0,0);
      }else if(f.kind===2){
        // 小菊花：细长瓣
        ctx.ellipse(petR*0.62, 0, petR*0.62, petR*0.14, 0, 0, Math.PI*2);
      }else if(f.kind===3){
        // 玫瑰感：重叠圆瓣
        ctx.ellipse(petR*0.45, 0, petR*0.58, petR*0.30, 0.35, 0, Math.PI*2);
      }else if(f.kind===4){
        // 樱花感：宽瓣 + 缺口（简单）
        ctx.ellipse(petR*0.55, 0, petR*0.60, petR*0.32, 0, 0, Math.PI*2);
      }else{
        // 星形花：更“品种丰富”
        ctx.moveTo(petR*0.2, 0);
        ctx.quadraticCurveTo(petR*0.85, -petR*0.15, petR*1.05, 0);
        ctx.quadraticCurveTo(petR*0.85,  petR*0.15, petR*0.2, 0);
      }
      ctx.fill();
      ctx.restore();
    }

    ctx.shadowBlur = 0;

    // 花芯
    ctx.globalAlpha = f.a;
    const coreR = S * (0.22 + 0.06*(f.kind%3));
    const cg = ctx.createRadialGradient(0,0,0,0,0,coreR*1.6);
    cg.addColorStop(0, "#ffffff");
    cg.addColorStop(0.35, f.core);
    cg.addColorStop(1, "rgba(255,255,255,0)");
    ctx.fillStyle = cg;
    ctx.beginPath();
    ctx.arc(0,0,coreR*1.6,0,Math.PI*2);
    ctx.fill();

    // 细节点点（花粉附着）
    ctx.globalAlpha = 0.35 * f.a;
    ctx.fillStyle = "rgba(255,255,255,1)";
    for(let k=0;k<6;k++){
      const px = rand(-coreR*0.8, coreR*0.8);
      const py = rand(-coreR*0.8, coreR*0.8);
      ctx.beginPath();
      ctx.arc(px,py,rand(0.6,1.2),0,Math.PI*2);
      ctx.fill();
    }

    ctx.restore();
  }

  function frame(now){
    const elapsed = now - start;

    // 整体透明度 a（进/停/出）
    let a;
    if(elapsed < durIn) a = easeOutCubic(elapsed/durIn);
    else if(elapsed < durIn + durHold) a = 1;
    else a = 1 - easeOutCubic((elapsed - durIn - durHold)/durOut);
    a = Math.max(0, Math.min(1, a));

    FX.clear();

    // 背景：鲜艳渐变（让“花海”更饱满）
    ctx.globalAlpha = 0.55 * a;
    const sky = ctx.createLinearGradient(0,0,W,H);
    sky.addColorStop(0, pick(bg));
    sky.addColorStop(0.5, "rgba(255,255,255,0.10)");
    sky.addColorStop(1, pick(bg));
    ctx.fillStyle = sky;
    ctx.fillRect(0,0,W,H);
    ctx.globalAlpha = 1;

    // 花朵“盛开进度”（0~1）
    const open = Math.min(1, elapsed/durIn);
    const openE = easeOutCubic(open);

    // 画花
    ctx.globalAlpha = a;
    for(const f of flowers){
      // 缓慢漂浮
      f.rot += f.vr;
      f.y += f.vy;
      f.x += f.vx;

      // 环绕回屏
      if(f.x < -80) f.x = W+80;
      if(f.x > W+80) f.x = -80;
      if(f.y < -80) f.y = H+80;
      if(f.y > H+80) f.y = -80;

      // 每朵花开得不一样：openE * f.pop
      const o = Math.min(1, openE * f.pop);
      drawFlower(f, o);
    }
    ctx.globalAlpha = 1;

    // 花粉闪光
    ctx.globalAlpha = 1;
    for(const p of pollen){
      p.x += p.vx; p.y += p.vy;
      if(p.x<0) p.x=W; if(p.x>W) p.x=0;
      if(p.y<0) p.y=H; if(p.y>H) p.y=0;

      ctx.globalAlpha = p.a * a;
      ctx.fillStyle = "rgba(255,255,255,1)";
      ctx.beginPath();
      ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    if(elapsed < total){
      requestAnimationFrame(frame);
    }else{
      FX.clear();
      FX.c.classList.remove("on-top");
      EFFECT_LOCK = false;
    }
  }

  requestAnimationFrame(frame);
}

// ===== Effect 06：小兔小猫金鱼 =====
function triggerEffect_06(){
  if(EFFECT_LOCK) return;
  EFFECT_LOCK = true;
  FX.c.classList.add("on-top");

  const ctx = FX.ctx;
  const W = window.innerWidth, H = window.innerHeight;

  const start = performance.now();
  const durIn = 520;
  const durHold = 2200;
  const durOut = 680;
  const total = durIn + durHold + durOut;

  const clamp01 = x => Math.max(0, Math.min(1, x));
  const easeOutBack = (t)=>{
    const c1 = 1.70158, c3 = c1+1;
    return 1 + c3*Math.pow(t-1,3) + c1*Math.pow(t-1,2);
  };
  const easeOutCubic = t => 1 - Math.pow(1-t, 3);

  function drawStickerShadow(x,y,r,a){
    ctx.save();
    ctx.globalAlpha = 0.14 * a;
    ctx.fillStyle = "rgba(0,0,0,1)";
    ctx.beginPath();
    ctx.ellipse(x, y + r*0.95, r*1.05, r*0.26, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  // --- Q 版小兔 ---
  function drawBunny(x,y,s,rot,a){
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(rot);
    ctx.scale(s,s);
    ctx.globalAlpha = a;

    // 外圈白描边（更像头像贴纸）
    ctx.lineWidth = 6;
    ctx.strokeStyle = "rgba(255,255,255,0.92)";

    // 头
    ctx.fillStyle = "rgba(255,230,240,0.95)";
    ctx.beginPath();
    ctx.arc(0, 0, 46, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();

    // 耳朵
    ctx.fillStyle = "rgba(255,230,240,0.95)";
    const ear = (ex,ey,rx,ry,tilt)=>{
      ctx.save();
      ctx.translate(ex,ey);
      ctx.rotate(tilt);
      ctx.beginPath();
      ctx.ellipse(0,0,rx,ry,0,0,Math.PI*2);
      ctx.fill();
      ctx.stroke();
      // 内耳
      ctx.fillStyle = "rgba(255,170,200,0.65)";
      ctx.beginPath();
      ctx.ellipse(0,0,rx*0.55,ry*0.65,0,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
      ctx.fillStyle = "rgba(255,230,240,0.95)";
    };
    ear(-18,-58,16,42,-0.18);
    ear( 18,-58,16,42, 0.18);

    // 眼睛
    ctx.fillStyle = "rgba(30,30,35,0.9)";
    ctx.beginPath(); ctx.arc(-16,-6,5,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc( 16,-6,5,0,Math.PI*2); ctx.fill();
    // 高光
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.beginPath(); ctx.arc(-14,-8,2,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc( 18,-8,2,0,Math.PI*2); ctx.fill();

    // 鼻子 + 嘴
    ctx.fillStyle = "rgba(255,120,150,0.85)";
    ctx.beginPath();
    ctx.arc(0, 6, 4.2, 0, Math.PI*2);
    ctx.fill();

    ctx.strokeStyle = "rgba(60,60,70,0.55)";
    ctx.lineWidth = 2.2;
    ctx.beginPath();
    ctx.moveTo(0, 10);
    ctx.quadraticCurveTo(-8, 18, -16, 12);
    ctx.moveTo(0, 10);
    ctx.quadraticCurveTo( 8, 18,  16, 12);
    ctx.stroke();

    ctx.restore();
  }

  // --- Q 版小猫 ---
  function drawCat(x,y,s,rot,a){
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(rot);
    ctx.scale(s,s);
    ctx.globalAlpha = a;

    // ===== 基础参数 =====
    const baseColor = "rgba(190,190,180,0.95)";   // 狸花底色（暖灰棕）
    const stripeColor = "rgba(120,95,65,0.55)";   // 条纹深色
    const outline = "rgba(255,255,255,0.92)";

    ctx.lineWidth = 6;
    ctx.strokeStyle = outline;

    // ===== 头 =====
    ctx.fillStyle = baseColor;
    ctx.beginPath();
    ctx.arc(0, 0, 48, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();

    // ===== 耳朵 =====
    function ear(ex,ey,flip){
      ctx.save();
      ctx.translate(ex,ey);
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.lineTo(18*flip,-26);
      ctx.lineTo(32*flip,2);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // 内耳
      ctx.fillStyle = "rgba(240,170,160,0.55)";
      ctx.beginPath();
      ctx.moveTo(6*flip,-2);
      ctx.lineTo(16*flip,-16);
      ctx.lineTo(22*flip,0);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
      ctx.fillStyle = baseColor;
    }
    ear(-22,-34,-1);
    ear( 22,-34, 1);

// ===== 狸花条纹（头部 · 可爱版）=====
ctx.strokeStyle = stripeColor;
ctx.lineWidth = 3.0;
ctx.lineCap = "round";

// —— 额头 M 纹（更挺拔，不下塌）——
ctx.beginPath();
ctx.moveTo(-18, -24);
ctx.quadraticCurveTo(-10, -34, 0, -26);
ctx.quadraticCurveTo( 10, -34, 18, -24);
ctx.stroke();

// 中央竖纹（可选但很加分）
ctx.beginPath();
ctx.moveTo(0, -26);
ctx.quadraticCurveTo(0, -18, 0, -12);
ctx.stroke();

// —— 脸颊条纹（向外 + 微微上扬）——
for(const side of [-1, 1]){
  // 上条纹：微笑感
  ctx.beginPath();
  ctx.moveTo(16*side, -6);
  ctx.quadraticCurveTo(
    28*side, -10,   // 控制点向上
    34*side, -2     // 终点不再下垂
  );
  ctx.stroke();

  // 下条纹：外扩但不下垂
  ctx.beginPath();
  ctx.moveTo(14*side, 4);
  ctx.quadraticCurveTo(
    26*side, 6,     // 几乎水平
    32*side, 10
  );
  ctx.stroke();
}

    // ===== 眼睛 =====
    ctx.fillStyle = "rgba(30,30,35,0.9)";
    ctx.beginPath(); ctx.ellipse(-16,-6,6,4.6,0,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse( 16,-6,6,4.6,0,0,Math.PI*2); ctx.fill();

    // 眼睛高光
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.beginPath(); ctx.arc(-14,-8,2,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc( 18,-8,2,0,Math.PI*2); ctx.fill();

    // ===== 鼻子 =====
    ctx.fillStyle = "rgba(180,110,90,0.9)";
    ctx.beginPath();
    ctx.arc(0, 6, 3.8, 0, Math.PI*2);
    ctx.fill();

    // ===== 嘴 =====
    ctx.strokeStyle = "rgba(60,60,70,0.55)";
    ctx.lineWidth = 2.2;
    ctx.beginPath();
    ctx.moveTo(0, 10);
    ctx.quadraticCurveTo(-8, 18, -16, 12);
    ctx.moveTo(0, 10);
    ctx.quadraticCurveTo( 8, 18,  16, 12);
    ctx.stroke();

    // ===== 胡须 =====
    ctx.globalAlpha = a*0.7;
    ctx.lineWidth = 2;
    for(const side of [-1,1]){
      ctx.beginPath();
      ctx.moveTo(10*side, 10);
      ctx.lineTo(34*side,  6);
      ctx.moveTo(10*side, 14);
      ctx.lineTo(34*side, 14);
      ctx.stroke();
    }
    ctx.globalAlpha = a;

    ctx.restore();
  }

  // --- Q 版金鱼 ---
  function drawGoldfish(x,y,s,rot,a){
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(rot);
    ctx.scale(s,s);
    ctx.globalAlpha = a;

    ctx.lineWidth = 6;
    ctx.strokeStyle = "rgba(255,255,255,0.92)";

    // 身体椭圆
    ctx.fillStyle = "rgba(255,140,40,0.95)";
    ctx.beginPath();
    ctx.ellipse(0, 0, 52, 38, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();

    // 尾巴（扇形）
    ctx.fillStyle = "rgba(255,90,40,0.85)";
    ctx.beginPath();
    ctx.moveTo(48, 0);
    ctx.quadraticCurveTo(92, -36, 102, 0);
    ctx.quadraticCurveTo(92,  36, 48, 0);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // 背鳍
    ctx.fillStyle = "rgba(255,180,120,0.55)";
    ctx.beginPath();
    ctx.moveTo(-8,-32);
    ctx.quadraticCurveTo(10,-58, 30,-34);
    ctx.quadraticCurveTo(8,-34, -8,-32);
    ctx.closePath();
    ctx.fill();

    // 眼睛
    ctx.fillStyle = "rgba(30,30,35,0.9)";
    ctx.beginPath(); ctx.arc(-18,-6,4.6,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.beginPath(); ctx.arc(-16,-8,1.8,0,Math.PI*2); ctx.fill();

    // 腮红点
    ctx.fillStyle = "rgba(255,230,230,0.45)";
    ctx.beginPath(); ctx.arc(-6, 10, 8, 0, Math.PI*2); ctx.fill();

    ctx.restore();
  }

  function frame(now){
    const elapsed = now - start;

    // 总体 alpha
    let a;
    if(elapsed < durIn) a = easeOutCubic(elapsed/durIn);
    else if(elapsed < durIn + durHold) a = 1;
    else a = 1 - easeOutCubic((elapsed - durIn - durHold)/durOut);
    a = clamp01(a);

    FX.clear();

    // 弹出 scale（有一点弹性）
    const pop = elapsed < durIn ? clamp01(elapsed/durIn) : 1;
    const s = elapsed < durIn ? easeOutBack(pop) : 1;

    // 晃动（很轻微）
    const wig = Math.sin((now - start)/220) * 0.06;      // 角度
    const bob = Math.sin((now - start)/260) * 6;         // 上下

    // 三个角色的位置（屏幕中间偏下）
    const baseY = H * 0.56 + bob;
    const gap = Math.min(W*0.22, 230);

    const bunnyX = W*0.5 - gap;
    const catX   = W*0.5;
    const fishX  = W*0.5 + gap;

    // 贴纸阴影
    drawStickerShadow(bunnyX, baseY, 48, a);
    drawStickerShadow(catX,   baseY, 48, a);
    drawStickerShadow(fishX,  baseY, 48, a);

    // 画三只（稍微错开晃动相位，显得更可爱）
    drawBunny(bunnyX, baseY, 0.95*s, wig*0.9, a);
    drawCat(  catX,   baseY, 0.98*s, -wig*0.7, a);
    drawGoldfish(fishX, baseY, 0.92*s, wig*0.8, a);

    if(elapsed < total){
      requestAnimationFrame(frame);
    }else{
      FX.clear();
      FX.c.classList.remove("on-top");
      EFFECT_LOCK = false;
    }
  }

  requestAnimationFrame(frame);
}
  
// ===== Effect 花火：只剩贺卡时花火绽放 =====
function triggerEffect_FIREWORKS(){
  if(EFFECT_LOCK) return;           // 如果你希望烟花不和别的特效抢锁，也可以不锁
  EFFECT_LOCK = true;
  FX.c.classList.add("on-top");     // 确保在最上层

  const ctx = FX.ctx;
  const W = window.innerWidth, H = window.innerHeight;

  const start = performance.now();
  const total = 9000;               // 持续时间（ms）— 想更久就 12000/15000
  const spawnEvery = 520;           // 每簇间隔（ms）— 越小越密，但也更耗
  const gravity = 0.028;

  // 根据屏幕面积自适应粒子数（保证不因高分辨率卡）
  const area = W * H;
  const maxParticlesPerBurst = area > 6_000_000 ? 48 : area > 3_000_000 ? 60 : 72; // 4K 更少

  const rand = (a,b)=>Math.random()*(b-a)+a;
  const pick = arr => arr[(Math.random()*arr.length)|0];
  const clamp01 = x => Math.max(0, Math.min(1, x));
  const easeOutCubic = t => 1 - Math.pow(1-t,3);

  // 鲜艳烟花颜色
  const colors = [
    [255,  45,  85], [255,  59,  48], [255, 149,   0], [255, 214,  10],
    [ 52, 199,  89], [  0, 199, 190], [ 50, 173, 230], [ 10, 132, 255],
    [ 94,  92, 230], [191,  90, 242], [255, 105, 180]
  ];

  const particles = [];
  let nextSpawn = start + 180;

  function addBurst(){
    // 在天空区域生成（上半~2/3），避免挡住卡片太多
    const cx = rand(W*0.18, W*0.82);
    const cy = rand(H*0.12, H*0.45);

    const c = pick(colors);
    const n = Math.floor(rand(maxParticlesPerBurst*0.65, maxParticlesPerBurst));
    const speed = rand(2.2, 4.2);
    const size = rand(1.2, 2.4);

    // “一簇一簇”的感觉：角度均匀 + 少量扰动
    for(let i=0;i<n;i++){
      const a = (i/n) * Math.PI*2 + rand(-0.06,0.06);
      const sp = speed * rand(0.65, 1.05);
      particles.push({
        x: cx, y: cy,
        vx: Math.cos(a)*sp,
        vy: Math.sin(a)*sp,
        r: size * rand(0.7, 1.2),
        life: rand(900, 1400),
        born: performance.now(),
        col: c,
        tw: rand(0.6, 1.4) // 轻微闪烁
      });
    }

    // 少量“核心亮点”
    for(let k=0;k<6;k++){
      particles.push({
        x: cx, y: cy,
        vx: rand(-0.6,0.6),
        vy: rand(-0.6,0.6),
        r: rand(1.8, 3.0),
        life: rand(520, 820),
        born: performance.now(),
        col: [255,255,255],
        tw: rand(0.8, 1.2)
      });
    }
  }

  function frame(now){
    const elapsed = now - start;
    const p = clamp01(elapsed / total);

    // 整体透明度：淡入 → 保持 → 淡出
    let a;
    if(elapsed < 900) a = easeOutCubic(elapsed/900);
    else if(elapsed > total - 1200) a = 1 - easeOutCubic((elapsed-(total-1200))/1200);
    else a = 1;
    a = clamp01(a);

    // 透明拖尾：用清除 + 低透明度覆盖“擦掉上一帧”，但不加黑底
    ctx.save();
    ctx.globalCompositeOperation = "destination-out";
    // 0.10~0.22：数值越大，拖尾越短；越小，残影越长
    ctx.globalAlpha = 0.14 * a;
    ctx.fillRect(0, 0, W, H);
    ctx.restore();

    // 生成新烟花
    if(now >= nextSpawn && elapsed < total - 1300){
      addBurst();
      nextSpawn = now + spawnEvery + rand(-120, 120);
    }

    // 更新/绘制粒子
    ctx.save();
    ctx.globalCompositeOperation = "lighter";

    for(let i=particles.length-1; i>=0; i--){
      const pt = particles[i];
      const age = now - pt.born;
      const t = age / pt.life;
      if(t >= 1){
        particles.splice(i,1);
        continue;
      }

      pt.vy += gravity;
      pt.x += pt.vx;
      pt.y += pt.vy;

      // 边界外就丢掉
      if(pt.x < -50 || pt.x > W+50 || pt.y < -60 || pt.y > H+60){
        particles.splice(i,1);
        continue;
      }

      // 闪烁 + 渐隐
      const twinkle = 0.6 + 0.4*Math.sin(now/80 * pt.tw + i);
      const alpha = (1 - t) * a * twinkle * 1.15; // 让粒子更亮

      const [r,g,b] = pt.col;
      ctx.globalAlpha = alpha;
      ctx.fillStyle = `rgba(${r},${g},${b},1)`;

      // 小光晕
      // const glow = pt.r * 6;
      // const rg = ctx.createRadialGradient(pt.x, pt.y, 0, pt.x, pt.y, glow);
      // rg.addColorStop(0, `rgba(${r},${g},${b},0.65)`);
      // rg.addColorStop(1, `rgba(${r},${g},${b},0)`);
      // ctx.fillStyle = rg;
      // ctx.beginPath();
      // ctx.arc(pt.x, pt.y, glow, 0, Math.PI*2);
      // ctx.fill();
      // 小光晕：更克制，避免一团雾
      const glow = Math.max(8, pt.r * 3);
      const rg = ctx.createRadialGradient(pt.x, pt.y, 0, pt.x, pt.y, glow);
      rg.addColorStop(0, `rgba(${r},${g},${b},0.35)`);
      rg.addColorStop(1, `rgba(${r},${g},${b},0)`);
      ctx.fillStyle = rg;
      ctx.beginPath();
      ctx.arc(pt.x, pt.y, glow, 0, Math.PI*2);
      ctx.fill();

      // 细火花：沿速度方向拉一小段线，烟花会更“干净锐利”
      ctx.globalAlpha = alpha;
      ctx.strokeStyle = `rgba(${r},${g},${b},1)`;
      ctx.lineWidth = 1.1; // 线条更细：0.9~1.3
      ctx.beginPath();
      ctx.moveTo(pt.x, pt.y);
      ctx.lineTo(pt.x - pt.vx*2.6, pt.y - pt.vy*2.6);
      ctx.stroke();

      // 粒子点
      ctx.globalAlpha = alpha;
      ctx.fillStyle = `rgba(${r},${g},${b},1)`;
      ctx.beginPath();
      // ctx.arc(pt.x, pt.y, pt.r, 0, Math.PI*2);
      ctx.arc(pt.x, pt.y, pt.r*0.75, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.restore();
    ctx.globalAlpha = 1;

    if(elapsed < total){
      requestAnimationFrame(frame);
    }else{
      FX.clear();
      FX.c.classList.remove("on-top");
      EFFECT_LOCK = false;
    }
  }

  requestAnimationFrame(frame);
}
// ===== Effect End =====
  
function createPopup({text, kind="small"}){
  const el = document.createElement("div");
  el.className = `popup ${kind} ${kind==="letter" ? "floaty" : "pop-in"}`;

  // 背景柔和色
  el.style.background = pick(pastel);

  // 把结构塞进去（防止黑屏）
  const title = kind==="letter" ? "贺卡" : pick(titles);
  el.innerHTML = `
    <div class="bar">
      <div class="title"><span class="dot"></span><span>${title}</span></div>
      <button class="close" aria-label="close">×</button>
    </div>
    <div class="content"></div>
  `;
  el.querySelector(".content").textContent = text;

  // 关键：短窗从很高的 z-index 开始，长信固定很低
  if (kind === "letter") {
    el.style.zIndex = "0";
  } else {
    el.style.zIndex = String(++topZ);
  }

  // 关键：长信插到 DOM 最前面（永远在最底层）
  if (kind === "letter") {
    document.body.insertBefore(el, document.body.firstChild);
  } else {
    document.body.appendChild(el);
  }

  // 位置：长信尽量居中，短窗随机
  const pad = 12;
  const rect = el.getBoundingClientRect();

  let x, y;
  if(kind === "letter"){
    x = (window.innerWidth - rect.width) / 2;
    y = clamp((window.innerHeight - rect.height) / 2, pad, window.innerHeight - rect.height - pad);
  }else{
    x = rand(pad, window.innerWidth - rect.width - pad);
    y = rand(pad, window.innerHeight - rect.height - pad);
  }
  el.style.left = `${x}px`;
  el.style.top  = `${y}px`;

  // 置顶：短窗可置顶，长信不允许置顶（保持底层）
  el.addEventListener("mousedown", () => {
    if(kind !== "letter") el.style.zIndex = String(++topZ);
  });

  // 关闭
  el.querySelector(".close").addEventListener("click", (e) => {
    e.stopPropagation();
    // 如果关闭的是触发句 → 按序号变量关闭
    if(kind === "small"){
      if(text === TRIGGER_TEXT_01) triggerEffect_01();
      if(text === TRIGGER_TEXT_02) triggerEffect_02();
      if(text === TRIGGER_TEXT_03) triggerEffect_03();
      if(text === TRIGGER_TEXT_04) triggerEffect_04();
      if(text === TRIGGER_TEXT_05) triggerEffect_05();
      if(text === TRIGGER_TEXT_06) triggerEffect_06();
    }
    el.remove();
    maybeStartFireworks(); // 每次关闭检查是否只剩贺卡
  });

  // 拖拽（标题栏）
  const bar = el.querySelector(".bar");
  let dragging = false;
  let startX=0, startY=0, startLeft=0, startTop=0;

  bar.addEventListener("mousedown", (e) => {
    dragging = true;
    bar.style.cursor = "grabbing";
    if(kind !== "letter") el.style.zIndex = String(++topZ);

    startX = e.clientX;
    startY = e.clientY;
    startLeft = parseFloat(el.style.left);
    startTop  = parseFloat(el.style.top);
    e.preventDefault();
  });

  window.addEventListener("mousemove", (e) => {
    if(!dragging) return;
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;

    const r = el.getBoundingClientRect();
    let nx = startLeft + dx;
    let ny = startTop  + dy;

    nx = clamp(nx, pad, window.innerWidth - r.width - pad);
    ny = clamp(ny, pad, window.innerHeight - r.height - pad);

    el.style.left = `${nx}px`;
    el.style.top  = `${ny}px`;
  });

  window.addEventListener("mouseup", () => {
    if(!dragging) return;
    dragging = false;
    bar.style.cursor = "grab";
  });

  return el;
}

// 只剩贺卡时，触发烟花效果
function maybeStartFireworks(){
  if(FIREWORKS_SHOWN) return;
  // 只剩长贺卡：页面上还有且仅有 1 个 .popup.letter
  const letters = document.querySelectorAll(".popup.letter");
  const popups  = document.querySelectorAll(".popup");
  if(letters.length === 1 && popups.length === 1){
    FIREWORKS_SHOWN = true;
    triggerEffect_FIREWORKS();
  }
}

  // === 主流程：短句（不重复）刷完 → 弹长信（底层） ===
  // 初始先来一点短窗（不超过队列长度）
  const initialCount = Math.min(10, shortMsgs.length);
  for(let i=0;i<initialCount;i++){
    const msg = nextShort();
    if(msg) createPopup({text: msg, kind:"small"});
  }

  // 持续刷短窗，直到队列用完
  const intervalMs = 160; // 密度：调小更爆
  const timer = setInterval(() => {
    if(letterShown) return;

    const msg = nextShort();
    if(msg){
      createPopup({text: msg, kind:"small"});
      return;
    }

    // 短句全部用完：停止刷短窗，弹出长信（但在底层）
    clearInterval(timer);
    letterShown = true;
    createPopup({text: longLetter, kind:"letter"});
  }, intervalMs);


  
</script>
</body>
</html>
