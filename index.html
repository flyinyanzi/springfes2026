<!doctype html>
<html lang="zh">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Popups + Long Letter</title>
  <style>
    html, body { height: 100%; }
    body{
      margin:0;
      overflow:hidden;
      background: radial-gradient(1200px 700px at 60% 25%, #2b2f3a, #0d0f14);
      font-family: system-ui, -apple-system, "PingFang SC", "Microsoft YaHei", sans-serif;
      isolation: isolate;
    }

    /* 通用弹窗 */
    .popup{
      position:absolute;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.26);
      box-shadow: 0 18px 40px rgba(0,0,0,.45);
      backdrop-filter: blur(10px);
      user-select:none;
      overflow:hidden;
      transform-origin: 30% 30%;
    }

    .bar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 10px 10px 8px 12px;
      cursor: grab;
      border-bottom: 1px solid rgba(255,255,255,.18);
      background: linear-gradient(to bottom, rgba(255,255,255,.16), rgba(255,255,255,.04));
    }
    .title{
      display:flex;
      align-items:center;
      gap:8px;
      font-size: 12px;
      opacity:.92;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 72%;
      color: rgba(20,20,20,.86);
    }
    .dot{
      width:9px;height:9px;border-radius:50%;
      background: rgba(20,20,20,.28);
      box-shadow: 0 0 0 2px rgba(255,255,255,.30) inset;
      flex: 0 0 auto;
    }
    .close{
      width: 28px;
      height: 28px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,.24);
      background: rgba(255,255,255,.18);
      color: rgba(20,20,20,.75);
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 16px;
      line-height: 1;
    }
    .close:hover{ background: rgba(255,255,255,.30); }

    .content{
      padding: 10px 12px 12px 12px;
      font-size: 14px;
      line-height: 1.6;
      color: rgba(20,20,20,.86);
      user-select:text;
      white-space: pre-wrap;      /* 自动换行 + 支持 \n */
      word-break: break-word;     /* 避免长单词撑爆 */
    }

    /* 短弹窗 */
    .popup.small{ width: 280px; }
    .popup.small .content{ max-height: 120px; overflow:auto; }

    /* 长信窗（大，滚动，不限字数） */
    .popup.letter{
      width: min(720px, calc(100vw - 24px));
      height: min(78vh, 680px);
    }
    .popup.letter .content{
      height: calc(100% - 52px);
      overflow:auto;
      font-size: 15px;
      line-height: 1.75;
      padding: 18px 18px 18px 18px;
    }

    /* 滚动条（可选） */
    .content::-webkit-scrollbar{ width: 10px; }
    .content::-webkit-scrollbar-thumb{
      background: rgba(0,0,0,.12);
      border-radius: 99px;
      border: 2px solid rgba(255,255,255,.55);
    }

    /* 弹出动画 + 轻微抖动 */
    .pop-in{
      animation: popIn .22s ease-out forwards, jitter 1.8s ease-in-out infinite;
      transform: translateY(10px) scale(.98);
      opacity: 0;
    }
    @keyframes popIn{
      to { opacity: 1; transform: translateY(0) scale(1); }
    }
    @keyframes jitter{
      0%,100% { translate: 0 0; }
      50% { translate: 0.6px -0.6px; } /* 很轻的抖动 */
    }

    /* 长信更像漂浮底稿 */
    .floaty{
      animation: popIn .22s ease-out forwards, float 3.2s ease-in-out infinite;
      transform: translateY(10px) scale(.98);
      opacity: 0;
    }
    @keyframes float{
      0%,100% { transform: translateY(0) scale(1); }
      50%     { transform: translateY(-6px) scale(1); }
    }

    .hint{
      position: fixed;
      left: 12px;
      bottom: 12px;
      font-size: 12px;
      opacity: .55;
      color: #fff;
      user-select:none;
    }

    #fx{
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 4; /* 背景之上、弹窗之下（弹窗 z-index>=1000） */
    }
    body.night-sky{ background: radial-gradient(1100px 700px at 60% 25%, #0b1a3a, #05060d); }

  </style>
</head>
<body>
  <div class="hint">短句：随机顺序且不重复｜长信：最底层｜都可拖拽/关闭</div>
  <canvas id="fx"></canvas>

<script>
  // ========= 编辑贺卡内容：短句 & 长信 =========

  // 柔和色（粉/蓝/绿）
  const pastel = [
    "#ffe0ea", "#ffd9f2", "#ffe9d2", "#fff4cc",
    "#dff7ff", "#d9e8ff", "#e6ddff",
    "#d9ffe9", "#dfffe0", "#e8fff7"
  ];

  // 约 30 条短句（随机顺序，但每条只出现一次）
  const shortMsgs = [
    "希望你每天早上起床都能精神充沛，元气满满迎接新的一天(*´∀`)♪",
    "在冰岛人们相信有精灵的存在，在冰川苔原、溶洞岩石之间，我们总能与自然通灵",
    "希望你每天上下班路上都顺顺利利的",
    "别总熬夜哦",
    "祝愿你天天开心(^○^)",
    "希望你工作顺利(ง•̀ω•́)ง",
    "希望你上班时不会遇到上司的信息轰炸，下班后也能独享悠闲时光",
    "工作忙的时候也要注意休息哦，多活动手指和颈椎～",
    "祝愿你在咖啡店里遇到的人都亲切和善",
    "希望你每天中午都有好好吃饭",
    "祝愿你能看到更多打动人心的演出，在音乐里治愈自己",
    "祝愿你在大人的世界里依然有一颗纯真的童心",
    "祝愿你在黑暗的魔法世界里能用“呼神护卫”为自己召唤出一头神秘而温暖的牝鹿",
    "",
    "",
    "即使工作忙也好好吃饭哦，要注意补充营养呢",
    "",
    "夜里睡觉记得盖好被子哦，别着凉",
    "姨妈期间也别喝凉的啦，多喝点温热滋补的",
    "喝水接力！工作忙的时候也记得多喝水哦",
    "注意天气变化，记得增添衣物，别感冒了",
    "冬天干燥的话记得用护手霜和身体乳哦",
    "他变成了一颗星星，会永远在夜空中闪耀",
    "希望你能去高山大川、隐秘森林、广阔天地……去很多好玩的地方",
    "希望你身体健康",
    "希望你心想事成",
    "希望你在自己感兴趣的领域里有美好的体验",
    "祝愿你的2026年如冬日暖阳般温暖、如锦绣繁花般绚烂",
    "",
    "希望你每天下班都能放松，开心度过夜晚的惬意时光"
  ];

  const TRIGGER_TEXT_01 = "他变成了一颗星星，会永远在夜空中闪耀";
  const TRIGGER_TEXT_02 = "祝愿你在黑暗的魔法世界里能用“呼神护卫”为自己召唤出一头神秘而温暖的牝鹿";


  // 最后一封长信（字数不限制）
  const longLetter = `
`;

  // ========= 逻辑部分 =========

  const titles = ["温柔提示", "提醒", "消息", "便签", "叮咚"];

  const rand = (min, max) => Math.random() * (max - min) + min;
  const pick = arr => arr[Math.floor(Math.random() * arr.length)];
  const clamp = (n, min, max) => Math.max(min, Math.min(n, max));

  let topZ = 1000;
  let letterShown = false;

  // 洗牌：保证随机顺序且不重复
  function shuffle(arr){
    const a = arr.slice();
    for(let i=a.length-1; i>0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  // 本轮短句队列：每条只用一次
  let shortQueue = shuffle(shortMsgs);
  function nextShort(){
    return shortQueue.length ? shortQueue.shift() : null; // 用完就 null（不再重复）
  }

// ===== FX Canvas 初始化 =====
const FX = (() => {
  const c = document.getElementById("fx");
  const ctx = c.getContext("2d");
  let w = 0, h = 0, dpr = 1;

  function resize(){
    dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    w = c.width = Math.floor(window.innerWidth * dpr);
    h = c.height = Math.floor(window.innerHeight * dpr);
    c.style.width = window.innerWidth + "px";
    c.style.height = window.innerHeight + "px";
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr, dpr);
  }
  window.addEventListener("resize", resize);
  resize();

  function clear(){
    ctx.clearRect(0,0,window.innerWidth,window.innerHeight);
  }

  return { c, ctx, clear };
})();

let EFFECT_LOCK = false; // 防止同时触发多个

// ===== Effect 01：夜空 + 流星 =====
function triggerEffect_01(){
  if(EFFECT_LOCK) return;
  EFFECT_LOCK = true;

  document.body.classList.add("night-sky");

  const ctx = FX.ctx;
  const W = window.innerWidth, H = window.innerHeight;

  // 画一层淡淡星星
  const stars = Array.from({length: Math.floor((W*H)/12000)}, () => ({
    x: Math.random()*W,
    y: Math.random()*H,
    r: Math.random()*1.2 + 0.2,
    a: Math.random()*0.7 + 0.1
  }));

  const start = performance.now();
  const dur = 1200;

  // 流星参数
  const sx = W + 200;
  const sy = Math.random() * (H * 0.35) + 40;
  const vx = -900;
  const vy = 520;

  function frame(t){
    const p = Math.min(1, (t - start) / dur);
    FX.clear();

    // stars
    for(const s of stars){
      ctx.globalAlpha = s.a * 0.9;
      ctx.fillStyle = "#fff";
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // shooting star
    const x = sx + vx * p;
    const y = sy + vy * p;
    const len = 240;
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(-18 * Math.PI/180);

    const g = ctx.createLinearGradient(-len, 0, 0, 0);
    g.addColorStop(0, "rgba(255,255,255,0)");
    g.addColorStop(0.65, "rgba(255,255,255,0.95)");
    g.addColorStop(1, "rgba(255,255,255,0)");
    ctx.strokeStyle = g;
    ctx.lineWidth = 2.2;
    ctx.shadowColor = "rgba(255,255,255,0.6)";
    ctx.shadowBlur = 12;

    ctx.beginPath();
    ctx.moveTo(-len, 0);
    ctx.lineTo(0, 0);
    ctx.stroke();
    ctx.restore();

    // fade out end
    if(p < 1){
      requestAnimationFrame(frame);
    }else{
      setTimeout(() => { FX.clear(); EFFECT_LOCK = false; }, 200);
    }
  }
  requestAnimationFrame(frame);
}

// ===== Effect 02：呼神护卫（雌鹿轮廓 + 粒子汇聚 + 发光）=====
function triggerEffect_02(){
  if(EFFECT_LOCK) return;
  EFFECT_LOCK = true;

  const ctx = FX.ctx;
  const W = window.innerWidth, H = window.innerHeight;

  const start = performance.now();
  const durSummon = 1800;  // 汇聚阶段
  const durHold   = 2400;  // 鹿显现与呼吸
  const total     = durSummon + durHold;

  // 粒子：从四周漂向中心偏右的位置（像咒语光芒聚集）
  const target = { x: W*0.62, y: H*0.58 };
  const particles = Array.from({length: 520}, () => {
    const edge = Math.floor(Math.random()*4);
    let x,y;
    if(edge===0){ x=Math.random()*W; y=-30; }
    if(edge===1){ x=W+30; y=Math.random()*H; }
    if(edge===2){ x=Math.random()*W; y=H+30; }
    if(edge===3){ x=-30; y=Math.random()*H; }
    return {
      x, y,
      vx: 0, vy: 0,
      r: Math.random()*1.6 + 0.4,
      a: Math.random()*0.65 + 0.15
    };
  });

  // 画一个“雌鹿轮廓”（用简单路径拟形：头、颈、背、腿）
  // 这不是电影级建模，但视觉上会像“银蓝色光之鹿”
  function drawDoeOutline(x, y, s, glow, breathe){
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(s, s);
    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    const alpha = 0.9;
    ctx.globalAlpha = alpha;

    // 外发光
    ctx.strokeStyle = `rgba(200,240,255,${0.30*glow})`;
    ctx.lineWidth = 18;
    ctx.shadowColor = `rgba(170,230,255,${0.85*glow})`;
    ctx.shadowBlur = 30;
    ctx.beginPath();

    // 一笔画的简化轮廓（抽象但像鹿）
    ctx.moveTo(-120, 20);          // 尾部
    ctx.quadraticCurveTo(-40, -10, 30, -20);   // 背
    ctx.quadraticCurveTo(80, -25, 110, -10);   // 肩
    ctx.quadraticCurveTo(135, 5, 140, 35);     // 胸前
    ctx.quadraticCurveTo(145, 70, 120, 85);    // 前腿上
    ctx.quadraticCurveTo(105, 95, 95, 130);    // 前腿下
    ctx.quadraticCurveTo(85, 165, 70, 170);    // 蹄
    ctx.moveTo(105, 85);
    ctx.quadraticCurveTo(88, 105, 88, 135);
    ctx.quadraticCurveTo(88, 168, 102, 170);

    // 颈与头
    ctx.moveTo(125, 40);
    ctx.quadraticCurveTo(130, 10, 115, -35);   // 颈
    ctx.quadraticCurveTo(95, -70, 60, -80);    // 头部轮廓
    ctx.quadraticCurveTo(30, -88, 10, -70);    // 口鼻
    ctx.quadraticCurveTo(28, -58, 45, -58);    // 下颌
    ctx.quadraticCurveTo(80, -58, 92, -40);    // 回到颈
    ctx.stroke();

    // 内描边（更亮）
    ctx.shadowBlur = 0;
    ctx.strokeStyle = `rgba(235,255,255,${0.95*glow})`;
    ctx.lineWidth = 2.2;
    ctx.beginPath();
    ctx.moveTo(-120, 20);
    ctx.quadraticCurveTo(-40, -10, 30, -20);
    ctx.quadraticCurveTo(80, -25, 110, -10);
    ctx.quadraticCurveTo(135, 5, 140, 35);
    ctx.quadraticCurveTo(145, 70, 120, 85);
    ctx.quadraticCurveTo(105, 95, 95, 130);
    ctx.quadraticCurveTo(85, 165, 70, 170);
    ctx.moveTo(105, 85);
    ctx.quadraticCurveTo(88, 105, 88, 135);
    ctx.quadraticCurveTo(88, 168, 102, 170);

    ctx.moveTo(125, 40);
    ctx.quadraticCurveTo(130, 10, 115, -35);
    ctx.quadraticCurveTo(95, -70, 60, -80);
    ctx.quadraticCurveTo(30, -88, 10, -70);
    ctx.quadraticCurveTo(28, -58, 45, -58);
    ctx.quadraticCurveTo(80, -58, 92, -40);
    ctx.stroke();

    // 呼吸起伏（轻微）
    if(breathe){
      // 在胸口附近加一点淡淡光
      ctx.globalAlpha = 0.35 * glow;
      const rg = ctx.createRadialGradient(120, 35, 2, 120, 35, 60);
      rg.addColorStop(0, "rgba(210,250,255,0.85)");
      rg.addColorStop(1, "rgba(210,250,255,0)");
      ctx.fillStyle = rg;
      ctx.beginPath();
      ctx.arc(120, 35, 60, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.restore();
  }

  function frame(t){
    const elapsed = t - start;
    FX.clear();

    // 背景轻暗 + 银蓝雾
    ctx.globalAlpha = 0.55;
    const bg = ctx.createRadialGradient(W*0.6, H*0.55, 40, W*0.6, H*0.55, Math.max(W,H));
    bg.addColorStop(0, "rgba(120,190,255,0.18)");
    bg.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = bg;
    ctx.fillRect(0,0,W,H);
    ctx.globalAlpha = 1;

    // 阶段 1：粒子汇聚
    const p1 = Math.min(1, elapsed / durSummon);
    const ease = (x)=>1-Math.pow(1-x,3);

    for(const pt of particles){
      const ex = ease(p1);
      // 朝目标靠拢 + 一点旋绕
      const dx = target.x - pt.x;
      const dy = target.y - pt.y;
      pt.x += dx * (0.012 + 0.018*ex);
      pt.y += dy * (0.012 + 0.018*ex);

      // 旋绕
      const swirl = 0.006 + 0.012*ex;
      const ox = -dy * swirl;
      const oy =  dx * swirl;
      pt.x += ox;
      pt.y += oy;

      ctx.globalAlpha = pt.a * (0.25 + 0.85*ex);
      ctx.fillStyle = "rgba(220,250,255,1)";
      ctx.beginPath();
      ctx.arc(pt.x, pt.y, pt.r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // 阶段 2：雌鹿显现 + 轻微游动
    if(elapsed > durSummon){
      const p2 = Math.min(1, (elapsed - durSummon) / durHold);
      const glow = 0.2 + 0.8 * ease(p2);

      const breath = Math.sin((elapsed - durSummon) / 280) * 0.5 + 0.5; // 0~1
      const bob = (Math.sin((elapsed - durSummon)/900) * 10);          // 轻微上下

      const x = target.x;
      const y = target.y + bob;
      const scale = 1.05 + 0.03*breath;

      drawDoeOutline(x, y, 1.0, glow, true);

      // 一点“魔法爆闪”
      ctx.globalAlpha = 0.18 * glow * (1-p2);
      ctx.fillStyle = "rgba(230,255,255,1)";
      ctx.beginPath();
      ctx.arc(x, y, 140, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    if(elapsed < total){
      requestAnimationFrame(frame);
    }else{
      // 慢慢清掉
      const endStart = performance.now();
      const fadeDur = 600;
      (function fade(tt){
        const pp = Math.min(1, (tt - endStart)/fadeDur);
        ctx.globalAlpha = 1 - pp;
        // 轻轻再画一帧雾（减少突兀）
        ctx.fillStyle = "rgba(0,0,0,0.06)";
        ctx.fillRect(0,0,W,H);
        ctx.globalAlpha = 1;
        if(pp < 1) requestAnimationFrame(fade);
        else { FX.clear(); EFFECT_LOCK = false; }
      })(endStart);
    }
  }

  requestAnimationFrame(frame);
}
// ===== Effect End =====
  
function createPopup({text, kind="small"}){
  const el = document.createElement("div");
  el.className = `popup ${kind} ${kind==="letter" ? "floaty" : "pop-in"}`;

  // 背景柔和色
  el.style.background = pick(pastel);

  // 把结构塞进去（防止黑屏）
  const title = kind==="letter" ? "贺卡" : pick(titles);
  el.innerHTML = `
    <div class="bar">
      <div class="title"><span class="dot"></span><span>${title}</span></div>
      <button class="close" aria-label="close">×</button>
    </div>
    <div class="content"></div>
  `;
  el.querySelector(".content").textContent = text;

  // 关键：短窗从很高的 z-index 开始，长信固定很低
  if (kind === "letter") {
    el.style.zIndex = "0";
  } else {
    el.style.zIndex = String(++topZ);
  }

  // 关键：长信插到 DOM 最前面（永远在最底层）
  if (kind === "letter") {
    document.body.insertBefore(el, document.body.firstChild);
  } else {
    document.body.appendChild(el);
  }

  // 位置：长信尽量居中，短窗随机
  const pad = 12;
  const rect = el.getBoundingClientRect();

  let x, y;
  if(kind === "letter"){
    x = (window.innerWidth - rect.width) / 2;
    y = clamp((window.innerHeight - rect.height) / 2, pad, window.innerHeight - rect.height - pad);
  }else{
    x = rand(pad, window.innerWidth - rect.width - pad);
    y = rand(pad, window.innerHeight - rect.height - pad);
  }
  el.style.left = `${x}px`;
  el.style.top  = `${y}px`;

  // 置顶：短窗可置顶，长信不允许置顶（保持底层）
  el.addEventListener("mousedown", () => {
    if(kind !== "letter") el.style.zIndex = String(++topZ);
  });

  // 关闭
  el.querySelector(".close").addEventListener("click", (e) => {
    e.stopPropagation();
    // 如果关闭的是触发句 → 按序号变量关闭
    if(kind === "small"){
      if(text === TRIGGER_TEXT_01) triggerEffect_01();
      if(text === TRIGGER_TEXT_02) triggerEffect_02();
    }
    el.remove();
  });

  // 拖拽（标题栏）
  const bar = el.querySelector(".bar");
  let dragging = false;
  let startX=0, startY=0, startLeft=0, startTop=0;

  bar.addEventListener("mousedown", (e) => {
    dragging = true;
    bar.style.cursor = "grabbing";
    if(kind !== "letter") el.style.zIndex = String(++topZ);

    startX = e.clientX;
    startY = e.clientY;
    startLeft = parseFloat(el.style.left);
    startTop  = parseFloat(el.style.top);
    e.preventDefault();
  });

  window.addEventListener("mousemove", (e) => {
    if(!dragging) return;
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;

    const r = el.getBoundingClientRect();
    let nx = startLeft + dx;
    let ny = startTop  + dy;

    nx = clamp(nx, pad, window.innerWidth - r.width - pad);
    ny = clamp(ny, pad, window.innerHeight - r.height - pad);

    el.style.left = `${nx}px`;
    el.style.top  = `${ny}px`;
  });

  window.addEventListener("mouseup", () => {
    if(!dragging) return;
    dragging = false;
    bar.style.cursor = "grab";
  });

  return el;
}


  // === 主流程：短句（不重复）刷完 → 弹长信（底层） ===
  // 初始先来一点短窗（不超过队列长度）
  const initialCount = Math.min(10, shortMsgs.length);
  for(let i=0;i<initialCount;i++){
    const msg = nextShort();
    if(msg) createPopup({text: msg, kind:"small"});
  }

  // 持续刷短窗，直到队列用完
  const intervalMs = 160; // 密度：调小更爆
  const timer = setInterval(() => {
    if(letterShown) return;

    const msg = nextShort();
    if(msg){
      createPopup({text: msg, kind:"small"});
      return;
    }

    // 短句全部用完：停止刷短窗，弹出长信（但在底层）
    clearInterval(timer);
    letterShown = true;
    createPopup({text: longLetter, kind:"letter"});
  }, intervalMs);


  
</script>
</body>
</html>
